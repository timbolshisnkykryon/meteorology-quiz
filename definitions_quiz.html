<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>בוחן מונחים במטאורולוגיה</title>
    <!-- טעינת Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- טעינת גופן Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Rubik:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* הגדרת גופן ברירת מחדל */
        body {
            font-family: 'Rubik', 'Inter', sans-serif;
        }

        .question-index-wrapper {
            background-color: #f1f5f9;
            border: 1px solid #cbd5f5;
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .question-index-wrapper h2 {
            font-size: 0.95rem;
            font-weight: 600;
            color: #0f172a;
            margin-bottom: 0.75rem;
        }

        .question-index-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            max-height: 10rem;
            overflow-y: auto;
            padding: 0.25rem;
        }

        .question-index-btn {
            width: 2.75rem;
            height: 2.75rem;
            border-radius: 9999px;
            border: 1px solid #cbd5f5;
            background-color: #f8fafc;
            color: #0f172a;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .question-index-btn:hover {
            background-color: #e2e8f0;
        }

        .question-index-btn.is-active {
            background-color: #1d4ed8;
            border-color: #1e3a8a;
            color: #ffffff;
            box-shadow: 0 10px 18px -10px rgba(29, 78, 216, 0.6);
        }

        .question-index-btn.is-in-progress {
            background-color: #fef3c7;
            border-color: #f59e0b;
            color: #92400e;
        }

        .question-index-btn.is-answered {
            background-color: #bae6fd;
            border-color: #0284c7;
            color: #0c4a6e;
        }

        #standalone-nav {
            margin-bottom: 1rem;
        }

        #standalone-nav a {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #0f172a;
            color: #ffffff;
            padding: 0.65rem 1rem;
            border-radius: 0.75rem;
            font-weight: 600;
            text-decoration: none;
            transition: background-color 0.2s ease;
        }

        #standalone-nav a:hover {
            background-color: #1e293b;
        }

        /* סגנון לספינר טעינה */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div class="bg-white rounded-lg shadow-2xl p-6 md:p-8 w-full max-w-2xl mx-auto">
        
        <!-- כותרת ומונה שאלות -->
        <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-4 mb-6 pb-4 border-b">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-800">בוחן מונחים במטאורולוגיה</h1>
            <div class="flex items-center gap-3">
                <button type="button"
                        onclick="shuffleQuestions()"
                        class="inline-flex items-center gap-2 bg-teal-100 text-teal-800 font-semibold py-2 px-3 rounded-lg hover:bg-teal-200 transition-colors duration-200">
                    ערבב/י שאלות
                </button>
                <div id="question-counter" class="text-lg font-semibold text-gray-600 bg-gray-100 px-3 py-1 rounded-full"></div>
            </div>
        </div>

        <div id="standalone-nav" class="hidden">
            <a href="index.html" aria-label="חזרה לתפריט הראשי">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5 8.25 12l7.5-7.5" />
                </svg>
                חזרה לתפריט הראשי
            </a>
        </div>

        <div class="question-index-wrapper" aria-label="ניווט מהיר בין השאלות">
            <h2>ניווט מהיר בין השאלות</h2>
            <div id="question-index" class="question-index-container" role="navigation"></div>
        </div>

        <!-- אזור השאלה -->
        <div id="quiz-container">
            <h2 class="text-xl font-semibold text-blue-700 mb-4">הגדר/י את המונח:</h2>
            <p id="term" class="text-3xl font-bold text-gray-900 mb-5"></p>

            <!-- שדה תשובה -->
            <textarea id="user-answer"
                      class="w-full h-32 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition"
                      placeholder="הקלד/י את הגדרתך כאן..."></textarea>

            <!-- כפתור הגשה -->
            <button id="submit-btn"
                    onclick="submitAnswer()"
                    class="w-full mt-4 bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 transition-colors duration-300 shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                בדוק את תשובתי
            </button>

            <!-- אזור משוב וטעינה -->
            <div id="feedback-container" class="mt-4 min-h-[50px] p-3 bg-gray-50 rounded-lg hidden flex items-center justify-center">
                <div id="loader" class="loader hidden"></div>
                <p id="feedback" class="text-md font-medium text-gray-700 whitespace-pre-line"></p>
            </div>

            <div id="reset-actions" class="mt-4 flex flex-col md:flex-row md:items-center gap-2 hidden">
                <button id="retry-btn"
                        type="button"
                        onclick="retryQuestion()"
                        class="w-full md:w-auto bg-white border border-blue-500 text-blue-600 font-semibold py-2 px-4 rounded-lg hover:bg-blue-50 transition-colors duration-200">
                    נסה/י שוב את השאלה הזו
                </button>
                <button id="reset-quiz-btn"
                        type="button"
                        onclick="restartQuiz()"
                        class="w-full md:w-auto bg-blue-100 text-blue-800 font-semibold py-2 px-4 rounded-lg hover:bg-blue-200 transition-colors duration-200">
                    אפס/י את כל המבחן
                </button>
            </div>

            <!-- אזור תשובה נכונה (מוסתר) -->
            <div id="correct-answer-container" class="mt-6 hidden border-t pt-4">
                <button id="show-answer-btn"
                        onclick="showAnswer()"
                        class="text-sm text-blue-600 hover:underline mb-3 font-medium">
                    הצג/הסתר תשובה מלאה
                </button>
                
                <div id="correct-answer" class="hidden bg-green-50 border border-green-200 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-green-800">הגדרה מדויקת:</h3>
                    <p id="definition" class="text-md text-green-900 mb-3"></p>
                    
                    <h3 class="text-lg font-bold text-green-800">הסבר:</h3>
                    <p id="explanation" class="text-md text-green-900 mb-3"></p>
                    
                    <h3 class="text-lg font-bold text-green-800">טיפ לזכירה:</h3>
                    <p id="tip" class="text-md text-green-900 italic"></p>
                </div>
            </div>

            <!-- כפתור שאלה הבאה (מוסתר) -->
            <button id="next-btn"
                    onclick="nextQuestion()"
                    class="w-full mt-4 bg-gray-700 text-white font-bold py-3 px-4 rounded-lg hover:bg-gray-800 transition-colors duration-300 shadow-md hidden focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                השאלה הבאה
            </button>
        </div>

        <!-- מסך סיום -->
        <div id="completion-screen" class="text-center hidden">
            <h2 class="text-3xl font-bold text-gray-800 mb-4">כל הכבוד!</h2>
            <p class="text-xl text-gray-600 mb-6">סיימת את הבוחן בהצלחה.</p>
            <button onclick="restartQuiz()"
                    class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 transition-colors duration-300 shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                התחל מחדש
            </button>
        </div>
    </div>

    <script>
        // מאגר השאלות מבוסס על 26 המונחים מקובץ ה-PDF
        const quizData = [
          {
            "term": "טמפרטורת נקודת הטל",
            "definition": "הטמפרטורה שיש לקרר אליה את גוש האוויר בתהליך איזוברי (בלחץ קבוע) על מנת שתתרחש רוויה. זוהי הטמפרטורה שבה האוויר מגיע ל-100% לחות יחסית ואדי המים מתחילים להתעבות.",
            "explanation": "אם האוויר ממשיך להתקרר מתחת לנקודה זו, אדי המים הופכים לטיפות מים זעירות (כמו טל, ערפל או עננים). בגובה בסיס הענן, טמפרטורת האוויר שווה לטמפרטורת נקודת הטל. ככל שנקודת הטל קרובה יותר לטמפרטורת האוויר, כך האוויר לח יותר.",
            "tip": "חשבו על 'נקודה' שבה האוויר 'מטפטף' - הטמפרטורה שבה ה'טל' מתחיל להיווצר."
          },
          {
            "term": "שקע ברומטרי",
            "definition": "אזור בו לחץ האוויר נמוך ביחס לסביבתו. כתוצאה מכך, אוויר בקרקע זורם פנימה (מתכנס) אל מרכז השקע בתנועה ציקלונית, ועולה למעלה (קונבקציה), מה שגורם להתקררות, התעבות ועננות.",
            "explanation": "התנועה הציקלונית (נגד כיוון השעון בחצי הכדור הצפוני) נגרמת מכוח קוריוליס. עליית האוויר היא הגורם המרכזי למזג אוויר לא יציב, עננים ומשקעים. דוגמאות לשקעים הן שקע חזיתי (כמו שקע קפריסאי) או שקע תרמלי.",
            "tip": "שקע = 'שוקע' פנימה. אוויר נכנס פנימה ועולה למעלה, כמו מים שיורדים בכיור (בצורה הפוכה)."
          },
          {
            "term": "כוח קוריוליס",
            "definition": "כוח מדומה הפועל על גופים (כמו אוויר) הנעים במערכת מסתובבת (כדור הארץ), וגורם להם לסטות מתנועה בקו ישר. בחצי הכדור הצפוני, ההטיה היא תמיד ימינה ובניצב לכיוון התנועה; בדרומי היא שמאלה.",
            "explanation": "כוח זה **מתאפס בקו המשווה** ו**מקסימלי בקטבים**. הוא זה שגורם לרוחות להסתובב סביב שקעים ורמות (ולא לזרום ישר מהרמה לשקע) וליצור את המאזן הגיאוסטרופי.",
            "tip": "קוריוליס = 'סיבוב'. בגלל סיבוב כדור הארץ, הרוח 'מחליקה' ימינה (בצפון)."
          },
          {
            "term": "טרופוספרה",
            "definition": "השכבה הנמוכה ביותר של האטמוספירה, המכילה כ-75% ממסת האוויר וכמעט את כל אדי המים, ובה מתרחשות כל תופעות מזג האוויר. היא מאופיינת בכך שהטמפרטורה יורדת עם העלייה בגובה, מכיוון שהיא מתחממת בעיקר מהקרקע.",
            "explanation": "היא מתחילה מהקרקע ומגיעה לגובה ממוצע של כ-10-12 ק\"מ. היא מסתיימת ב**טרופופאוזה**, שהיא הגבול העליון להתפתחות רוב העננים.",
            "tip": "טרופו = 'שינוי' (מיוונית). זו השכבה שבה מזג האוויר כל הזמן משתנה."
          },
          {
            "term": "זרם סילון",
            "definition": "רצועה צרה של רוחות מערביות חזקות מאוד (מעל 75 קשר) ברום האטמוספירה, בקרבת הטרופופאוזה. זרמים אלו נוצרים בגבולות בין גושי אוויר בטמפרטורות שונות.",
            "explanation": "קיימים שני סוגים עיקריים: **הסילון הפולרי** (הגלי יותר) ו**הסילון הסובטרופי**. הם זורמים בצורה גלית ומשפיעים מאוד על התפתחות שקעים ורמות על הקרקע. בתעופה, הם גורמים למערבולות ומשפיעים על חישובי דלק וזמני טיסה.",
            "tip": "סילון = מטוס סילון. זוהי 'אוטוסטרדה' של רוח מהירה בגובה שבו טסים מטוסי סילון."
          },
          {
            "term": "מפל אדיאבטי יבש",
            "definition": "קצב ההתקררות הקבוע של גוש אוויר לא רווי (לחות יחסית < 100%) כתוצאה מהתפשטותו בעת עלייה בגובה. קצב זה עומד על כ-9.8 מעלות צלזיוס לכל 1000 מטר.",
            "explanation": "זהו תהליך אדיאבטי (ללא החלפת חום עם הסביבה). כשאוויר עולה, הלחץ סביבו יורד, והוא מתפשט - פעולה זו מקררת אותו. אם האוויר יורד, הוא יידחס ויתחמם באותו קצב.",
            "tip": "יבש = מהיר. אוויר יבש מתקרר מהר בעלייה (כמעט 10° לק\"מ)."
          },
          {
            "term": "רמה ברומטרית",
            "definition": "אזור בו לחץ האוויר גבוה ביחס לסביבתו. כתוצאה מכך, אוויר בקרקע זורם החוצה (מתבדר) ממרכז הרמה בתנועה אנטי-ציקלונית, ואוויר מהשכבות הגבוהות שוקע (מתמוכך) למטה.",
            "explanation": "התנועה האנטי-ציקלונית (עם כיוון השעון בחצי הכדור הצפוני) נגרמת מכוח קוריוליס. אוויר שוקע מתחמם ומתייבש בתהליך אדיאבטי, ולכן רמות מזוהות עם מזג אוויר יציב, דיכוי עננים ושמיים בהירים.",
            "tip": "רמה = 'רם' וגבוה. אוויר יורד מלמעלה ומתפזר, מדכא עננים וגורם למזג אוויר נאה."
          },
          {
            "term": "שקע חזיתי",
            "definition": "שקע ברומטרי האופייני לקווי הרוחב הבינוניים, הנוצר ממפגש בין גוש אוויר קר לגוש אוויר חם. במפגש זה נוצרות חזיתות (חמה וקרה), האוויר החם (הקל) עולה מעל הקר, ונוצרים עננים ומשקעים.",
            "explanation": "דוגמה קלאסית בישראל היא **שקע קפריסאי** בחורף. עליית האוויר החם גורמת להתקררות, התעבות, יצירת עננות וסופות רעמים, בעיקר לאורך החזית הקרה.",
            "tip": "חזיתי = חזית/מלחמה. זוהי 'מלחמה' בין אוויר חם לאוויר קר, שיוצרת שקע ומזג אוויר סוער."
          },
          {
            "term": "מפל אדיאבטי לח",
            "definition": "קצב ההתקררות של גוש אוויר רווי (100% לחות) בעת עלייתו. קצב זה איטי מהמפל היבש (ממוצע כ-6°C ל-1000 מטר) מכיוון שמשתחרר **חום כמוס** בתהליך התעבות אדי המים לענן.",
            "explanation": "שחרור החום הכמוס 'מפצה' חלקית על ההתקררות הנגרמת מההתפשטות. קצב זה אינו קבוע ותלוי בטמפרטורה (ככל שחם יותר, יש יותר אדי מים להתעבות, והקצב איטי יותר). הוא קריטי לקביעת יציבות האוויר.",
            "tip": "לח = לאט. אוויר לח (רווי) מתקרר לאט יותר, כי יצירת הענן משחררת חום שמפצה על ההתקררות."
          },
          {
            "term": "התקרחות זגוגית",
            "definition": "סוג התקרחות מסוכן הנגרם מטיפות מים גדולות (כמו גשם) בקירור-יתר (מתחת 0°C). הטיפות פוגעות במשטחי המטוס, מחליקות לאחור וקופאות לאט, ויוצרות שכבת קרח חלקה, שקופה, דחוסה וקשה להסרה.",
            "explanation": "היא משנה בצורה חמורה את משקל המטוס ואת תכונותיו האווירודינמיות (צורת הכנף). חלקיקי קרח עלולים להישבר ולפגוע בגוף המטוס ובמנוע. יכול להיווצר גם בהנמכה מגובה רב אל תוך גשם.",
            "tip": "זגוגית = כמו זכוכית. קרח חלק ושקוף כמו זכוכית, ש'מזגג' את הכנף."
          },
          {
            "term": "חוק בויס בלוט",
            "definition": "כלל אצבע הקובע את הקשר בין כיוון הרוח למיקום מערכות הלחץ. בחצי הכדור הצפוני, כאשר עומדים עם הגב לכיוון הרוח, הלחץ הנמוך (השקע) יהיה משמאל והלחץ הגבוה (הרמה) מימין.",
            "explanation": "הכלל הפוך בחצי הכדור הדרומי. הוא נובע ישירות מהשפעת **כוח קוריוליס**, שגורם לרוח לזרום כמעט במקביל לאיזוברים (קווים שווי לחץ) ולא ישירות מהרמה לשקע.",
            "tip": "בויס בלוט = שמאל נמוך. כשאתה עם הגב לרוח (בצפון), צד שמאל שלך מצביע על הלחץ הנמוך."
          },
          {
            "term": "אינברסיה",
            "definition": "מצב אטמוספרי של **יציבות מוחלטת** שבו הטמפרטורה עולה עם הגובה. זהו היפוך של מפל הטמפרטורות הרגיל בטרופוספרה.",
            "explanation": "באינברסיה, שכבת אוויר חם נמצאת מעל אוויר קר. השכבה החמה פועלת כ'מכסה' ומונעת מהאוויר שמתחתיה לעלות. שכבה זו 'כולאת' לחות, זיהום אוויר ואובך קרוב לקרקע, כפי שקורה ב**אינברסיה המארינית** בקיץ בישראל או בערפל קרינה.",
            "tip": "אינברסיה = היפוך (Inverse). הטמפרטורה מתהפכת ועולה עם הגובה במקום לרדת."
          },
          {
            "term": "טרופופאוזה",
            "definition": "שכבת הביניים הדקה המפרידה בין הטרופוספרה לסטרטוספרה. היא מוגדרת כגובה שבו מפל הטמפרטורה (הירידה בטמפ' עם הגובה) נעצר או מתהפך (מתחילה אינברסיה).",
            "explanation": "גובה הטרופופאוזה משמש כ'תקרה' להתפתחות רוב מערכות מזג האוויר. ענני סערה מפותחים (קומולונימבוס) נתקלים בה ופסגותיהם מתפשטות לצדדים בצורת סדן.",
            "tip": "פאוזה = הפסקה. זוהי ההפסקה שבין הטרופוספרה לסטרטוספרה, שם מפל הטמפרטורה עושה 'הפסקה'."
          },
          {
            "term": "יציבות",
            "definition": "מצב המתאר את נטיית האוויר להתנגד לתנועה אנכית (יציב) או לעודד אותה (בלתי יציב). **במצב יציב**, גוש אוויר שמוזז ממקומו ישאף לחזור אליו (קר מסביבתו). **במצב בלתי יציב**, גוש אוויר שמוזז ימשיך להתרחק (חם מסביבתו).",
            "explanation": "היציבות נקבעת על ידי השוואת מפל הטמפרטורה של הסביבה למפלים האדיאבטיים (היבש והלח). יציבות (כמו באינברסיה) מדכאת עננים וערבול, אי-יציבות מעודדת התפתחות עננים ערמתיים וסערות.",
            "tip": "יציב = נשאר במקום. אוויר יציב לא אוהב לזוז וגורם למזג אוויר רגוע."
          },
          {
            "term": "פרץ רוח",
            "definition": "עלייה פתאומית, קצרה וחזקה במהירות הרוח, מעל המהירות הממוצעת. משבי רוח מקשים על שמירת מהירות קרקעית יציבה, ומהווים סכנה תעופתית בהמראה ונחיתה.",
            "explanation": "פרצי רוח (משבים) נגרמים לרוב על ידי ערבול באטמוספירה, או על ידי זרמים יורדים חזקים (Downdraft) מענני סערה (כמו מיקרוברסט).",
            "tip": "פרץ = פתאומי. כמו פרץ מים, זוהי 'מכה' פתאומית וחזקה של רוח."
          },
          {
            "term": "סטרטוקומולוס (Sc)",
            "definition": "ענן שכבתי נמוך בעל התפתחות ערמתית מעטה, הנראה כגוש או שכבה של עננים אפורים או לבנבנים עם גוונים המשתנים בסדירות. נוצר לעיתים קרובות מהתפשטות של פסגות קומולוס שנתקלו בשכבת אינברסיה יציבה.",
            "explanation": "אלו עננים נמוכים שנראים לעיתים קרובות כ'שמיכת טלאים' בשמיים. הם יכולים להיווצר גם כתוצאה מערבול (גזירת רוח) בתוך שכבת אוויר לחה. עננים אלו עשויים להוריד רסס או גשם קל.",
            "tip": "סטרטו (שכבתי) + קומולוס (ערמתי) = ערימות מרוחות בשכבה."
          },
          {
            "term": "קרינה קצרת גל",
            "definition": "קרינה אלקטרומגנטית בעלת אנרגיה גבוהה ואורך גל קצר (כמו אור נראה ו-UV). היא נפלטת מגופים חמים מאוד, ובראש ובראשונה מהשמש. האטמוספירה שקופה יחסית לקרינה זו.",
            "explanation": "בגלל שהאטמוספירה שקופה לה, היא מצליחה לחדור דרכה ולהגיע לקרקע ולחמם אותה. הקרקע, שהיא קרה יותר, פולטת בחזרה **קרינה ארוכת גל** (אינפרה-אדום), שהיא 'נבלעת' על ידי גזי חממה באטמוספירה (אפקט החממה).",
            "tip": "קצר = חם. השמש החמה פולטת קרינה קצרה."
          },
          {
            "term": "חזית חמה",
            "definition": "אזור מפגש שבו גוש אוויר חם נע לעבר גוש אוויר קר ונסוג. האוויר החם, שהוא קל יותר, 'מטפס' במתינות מעל האוויר הקר, וגורם להתפתחות עננות שכבתית נרחבת ומשקעים קלים ומתמשכים.",
            "explanation": "הטיפוס המתון יוצר אינברסיה המדכאת התפתחות ענני סערה. סדר העננים האופייני הוא צירוס (הכי גבוה וראשון), ואז אלטוסטרטוס ונימבוסטרטוס (ענן הגשם).",
            "tip": "חזית חמה = טיפוס מתון. האוויר החם מטפס לאט לאט על הקר, ויוצר 'שטיח' ארוך של עננים וגשם."
          },
          {
            "term": "צירוס (Ci)",
            "definition": "ענן גבוה (16,000-43,000 רגל) המורכב מגבישי קרח. הוא נראה בצורת סיבים, שערות או נוצות לבנות ועדינות, לרוב שקוף לשמש ולירח ואינו מוריד משקעים.",
            "explanation": "הופעתם יכולה לעתים לבשר על התקרבות של מערכת מזג אוויר, כמו חזית חמה (הם העננים הראשונים להופיע).",
            "tip": "צירוס נשמע כמו 'סירוס' (מסרק). העננים נראים כמו סיבים עדינים ש'סירקו' בשמיים."
          },
          {
            "term": "מיקרוברסט (Microburst)",
            "definition": "זרם אוויר אנכי יורד (Downdraft) חזק ומרוכז מאוד, הנוצר לרוב מענני סערה (Cb) המלווים בגשם חזק. בהגיעו אל הקרקע, הוא מתפשט החוצה ויוצר גזירות רוח אופקיות ואנכיות מסוכנות.",
            "explanation": "זוהי תופעה מסוכנת ביותר לתעופה, במיוחד בהמראה ונחיתה. היא גורמת לשינויים פתאומיים וחזקים בכיוון ועוצמת הרוח, העלולים 'להטיח' מטוס לקרקע.",
            "tip": "מיקרו = קטן ומרוכז, ברסט = התפרצות. התפרצות אוויר קטנה, מרוכזת ומסוכנת מאוד."
          },
          {
            "term": "קומולוס (Cu)",
            "definition": "ענן ערימתי נמוך ומבודד, שבסיסו אופקי וכהה, ופסגותיו מעוגלות ומבהיקות בלובנן. הוא נוצר כתוצאה מעליית אוויר חם (קונבקציה) מהקרקע באוויר בלתי יציב.",
            "explanation": "אלו לרוב עננים של 'מזג אוויר נאה'. הגדולים שבהם עשויים להוריד גשם. במצבי אי-יציבות חריפה, הם יכולים להמשיך להתפתח אנכית ולהפוך לענני סערה (קומולונימבוס).",
            "tip": "קומולוס = ערימה (מלטינית). ענן שנראה כמו ערימה של צמר גפן."
          },
          {
            "term": "טמפרטורה לחה",
            "definition": "הטמפרטורה הנמוכה ביותר שאליה ניתן לקרר גוש אוויר על ידי אידוי מים לתוכו (תהליך הצורך חום כמוס) עד למצב של רוויה.",
            "explanation": "זוהי הטמפרטורה שמודד מדחום שכוסה בבד לח. ככל שהאוויר יבש יותר, כך האידוי חזק יותר, והטמפרטורה הלחה נמוכה יותר מטמפרטורת האוויר. כשהאוויר רווי (100% לחות), אין אידוי, והטמפרטורה הלחה שווה לטמפרטורת האוויר.",
            "tip": "לחה = מדחום לח. מה שמדחום עם 'גרב' לחה היה מראה."
          },
          {
            "term": "סטרטוס (St)",
            "definition": "ענן שכבתי נמוך מאוד (מאות מטרים ופחות), אפור ואחיד, שגבולותיו אינם חדים. אם הוא נוגע בקרקע, הוא נקרא 'ערפל'.",
            "explanation": "הוא נוצר בתנאי יציבות אטמוספרית, לרוב בלילות לחים ויציבים. הוא מלווה בראות לקויה ויכול להוריד רסס קל.",
            "tip": "סטרטוס = שטיח (מלטינית 'שכבה'). ענן שנראה כמו שטיח אפור ואחיד בשמיים."
          },
          {
            "term": "לחות יחסית",
            "definition": "היחס, באחוזים, בין כמות אדי המים הנמצאת באוויר (או לחץ האדים הקיים) לבין הכמות המקסימלית שאותה האוויר יכול להכיל באותה טמפרטורה (לחץ אדי רוויה).",
            "explanation": "100% לחות יחסית משמעו שהאוויר רווי. לחות יחסית תלויה מאוד בטמפרטורה, מכיוון שאוויר חם יכול להכיל יותר אדי מים מאשר אוויר קר. זו הסיבה שלחות יחסית יורדת בצהריים (כשהטמפ' עולה) ועולה בלילה (כשהטמפ' יורדת).",
            "tip": "יחסית = יחס לטמפרטורה. כמה האוויר 'מלא' באדים, יחסית למקסימום שהוא יכול להחזיק בטמפרטורה הנוכחית."
          },
          {
            "term": "מערכת לחץ",
            "definition": "תבנית מאורגנת של לחץ אטמוספרי, המתבטאת באזור של לחץ גבוה (רמה) או לחץ נמוך (שקע) ביחס לסביבה. מערכות אלו קובעות את כיוון הרוח ואת אופי מזג האוויר.",
            "explanation": "**שקעים** (לחץ נמוך) גורמים להתכנסות ועליית אוויר, וליצירת עננים ומשקעים. **רמות** (לחץ גבוה) גורמים להתבדרות ושקיעת אוויר (התמוככות), ומזג אוויר יציב ונאה.",
            "tip": "מערכת = רמה או שקע. אלו המנועים הגדולים של מזג האוויר."
          },
          {
            "term": "שקע תרמלי",
            "definition": "שקע ברומטרי (לחץ נמוך) הנוצר כתוצאה מהתחממות חזקה של הקרקע באזור מסוים. ההתחממות גורמת לאוויר שמעל לעלות (קונבקציה) וליצור לחץ נמוך בקרקע.",
            "explanation": "דוגמה קטנה היא הבריזה הימית, הנוצרת משקע תרמלי קטן מעל היבשה החמה ביום. דוגמה גדולה היא **השקע המונסוני** (והאפיק הפרסי) בקיץ. דוגמה נוספת היא **שקע שרבי**, הנוצר מהפרשי הטמפרטורה בין מדבר סהרה החם לים התיכון הקר.",
            "tip": "תרמלי = חום. שקע שנוצר בגלל חום מהקרקע."
          }
        ];


        let currentQuestionIndex = 0;
        let shuffledQuizData = [];
        let isEvaluating = false;

        // רכיבי DOM
        const quizContainer = document.getElementById('quiz-container');
        const completionScreen = document.getElementById('completion-screen');
        const questionCounter = document.getElementById('question-counter');
        const termEl = document.getElementById('term');
        const userAnswerEl = document.getElementById('user-answer');
        const submitBtn = document.getElementById('submit-btn');
        const nextBtn = document.getElementById('next-btn');
        const feedbackContainer = document.getElementById('feedback-container');
        const loader = document.getElementById('loader');
        const feedbackEl = document.getElementById('feedback');
        const showAnswerBtn = document.getElementById('show-answer-btn');
        const correctAnswerContainer = document.getElementById('correct-answer-container');
        const correctAnswerEl = document.getElementById('correct-answer');
        const definitionEl = document.getElementById('definition');
        const explanationEl = document.getElementById('explanation');
        const tipEl = document.getElementById('tip');
        const questionIndexContainer = document.getElementById('question-index');
        const standaloneNav = document.getElementById('standalone-nav');
        const resetActions = document.getElementById('reset-actions');
        const retryBtn = document.getElementById('retry-btn');
        const resetQuizBtn = document.getElementById('reset-quiz-btn');

        const STORAGE_KEY = 'definitions_quiz_state_v1';
        let shuffledOrder = [];
        let questionStates = [];

        document.addEventListener('DOMContentLoaded', () => {
            if (window.self === window.top) {
                standaloneNav.classList.remove('hidden');
            }
            startQuiz();
        });

        function createEmptyState() {
            return { answer: '', feedback: '', showAnswer: false, status: 'unanswered' };
        }

        function loadSavedState() {
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (!stored) {
                    return null;
                }

                const parsed = JSON.parse(stored);
                if (!Array.isArray(parsed.order) || parsed.order.length !== quizData.length) {
                    localStorage.removeItem(STORAGE_KEY);
                    return null;
                }

                if (!Array.isArray(parsed.questionStates) || parsed.questionStates.length !== quizData.length) {
                    localStorage.removeItem(STORAGE_KEY);
                    return null;
                }

                if (!parsed.order.every(idx => Number.isInteger(idx) && idx >= 0 && idx < quizData.length)) {
                    localStorage.removeItem(STORAGE_KEY);
                    return null;
                }

                const sanitizedStates = parsed.questionStates.map(state => ({
                    answer: typeof state?.answer === 'string' ? state.answer : '',
                    feedback: typeof state?.feedback === 'string' ? state.feedback : '',
                    showAnswer: Boolean(state?.showAnswer),
                    status: state?.status === 'done' ? 'done' : 'unanswered'
                }));

                const savedIndex = Number.isInteger(parsed.currentQuestionIndex) ? parsed.currentQuestionIndex : 0;

                return {
                    order: parsed.order.slice(),
                    questionStates: sanitizedStates,
                    currentQuestionIndex: Math.min(Math.max(savedIndex, 0), quizData.length - 1),
                    completed: Boolean(parsed.completed)
                };
            } catch (error) {
                console.warn('Failed to load saved quiz state', error);
                return null;
            }
        }

        function saveState(extra = {}) {
            try {
                const payload = {
                    order: shuffledOrder,
                    questionStates,
                    currentQuestionIndex,
                    completed: extra.completed !== undefined ? extra.completed : !completionScreen.classList.contains('hidden')
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
            } catch (error) {
                console.warn('Failed to save quiz state', error);
            }
        }

        function clearSavedState() {
            try {
                localStorage.removeItem(STORAGE_KEY);
            } catch (error) {
                console.warn('Failed to clear quiz state', error);
            }
        }

        function renderQuestionIndex() {
            questionIndexContainer.innerHTML = '';
            shuffledQuizData.forEach((_, index) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.textContent = index + 1;
                button.className = 'question-index-btn';
                button.addEventListener('click', () => goToQuestion(index));
                questionIndexContainer.appendChild(button);
            });
        }

        function updateQuestionIndex() {
            const buttons = questionIndexContainer.querySelectorAll('button');
            buttons.forEach((btn, idx) => {
                btn.classList.remove('is-active', 'is-in-progress', 'is-answered');
                if (idx === currentQuestionIndex) {
                    btn.classList.add('is-active');
                }
                const state = questionStates[idx];
                if (!state) {
                    return;
                }
                if (state.status === 'done') {
                    btn.classList.add('is-answered');
                } else if (state.status === 'in-progress') {
                    btn.classList.add('is-in-progress');
                }
            });
        }

        function goToQuestion(index) {
            if (isEvaluating) {
                return;
            }
            currentQuestionIndex = index;
            loadQuestion();
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function startQuiz(reset = false) {
            let savedState = null;
            if (!reset) {
                savedState = loadSavedState();
            }

            if (savedState) {
                shuffledOrder = savedState.order.slice();
                shuffledQuizData = shuffledOrder.map(idx => quizData[idx]);
                questionStates = savedState.questionStates;
                currentQuestionIndex = savedState.currentQuestionIndex;
                isEvaluating = false;
                quizContainer.classList.toggle('hidden', savedState.completed);
                completionScreen.classList.toggle('hidden', !savedState.completed);
                renderQuestionIndex();
                if (savedState.completed) {
                    updateQuestionIndex();
                    saveState({ completed: true });
                } else {
                    loadQuestion();
                }
                return;
            }

            shuffledOrder = shuffleArray(Array.from({ length: quizData.length }, (_, idx) => idx));
            shuffledQuizData = shuffledOrder.map(idx => quizData[idx]);
            questionStates = shuffledQuizData.map(() => createEmptyState());
            currentQuestionIndex = 0;
            isEvaluating = false;
            quizContainer.classList.remove('hidden');
            completionScreen.classList.add('hidden');
            renderQuestionIndex();
            loadQuestion();
            saveState();
        }

        function loadQuestion() {
            updateQuestionIndex();

            if (currentQuestionIndex >= shuffledQuizData.length) {
                quizContainer.classList.add('hidden');
                completionScreen.classList.remove('hidden');
                saveState({ completed: true });
                return;
            }

            const question = shuffledQuizData[currentQuestionIndex];
            const state = questionStates[currentQuestionIndex];

            termEl.textContent = question.term;
            questionCounter.textContent = `שאלה ${currentQuestionIndex + 1} / ${shuffledQuizData.length}`;

            userAnswerEl.value = state.answer || '';
            loader.classList.add('hidden');

            if (state.status === 'done') {
                userAnswerEl.disabled = true;
                feedbackContainer.classList.remove('hidden');
                feedbackEl.textContent = state.feedback || '';
                submitBtn.classList.add('hidden');
                submitBtn.disabled = false;
                nextBtn.classList.remove('hidden');
                nextBtn.textContent = currentQuestionIndex === shuffledQuizData.length - 1 ? 'סיום הבוחן' : 'השאלה הבאה';
                correctAnswerContainer.classList.remove('hidden');
                retryBtn.classList.remove('hidden');
                retryBtn.disabled = false;
                if (state.showAnswer) {
                    correctAnswerEl.classList.remove('hidden');
                    showAnswerBtn.textContent = 'הסתר תשובה מלאה';
                    definitionEl.textContent = question.definition;
                    explanationEl.textContent = question.explanation;
                    tipEl.textContent = question.tip;
                } else {
                    correctAnswerEl.classList.add('hidden');
                    showAnswerBtn.textContent = 'הצג תשובה מלאה';
                }
            } else {
                userAnswerEl.disabled = false;
                feedbackContainer.classList.add('hidden');
                feedbackEl.textContent = '';
                submitBtn.classList.remove('hidden');
                submitBtn.disabled = false;
                nextBtn.classList.add('hidden');
                correctAnswerContainer.classList.add('hidden');
                correctAnswerEl.classList.add('hidden');
                showAnswerBtn.textContent = 'הצג תשובה מלאה';
                retryBtn.classList.add('hidden');
                retryBtn.disabled = true;
                if (state.status === 'in-progress') {
                    feedbackContainer.classList.remove('hidden');
                    feedbackEl.textContent = 'מעבד את תשובתך...';
                }
            }

            if (questionStates.some(s => s.status === 'done')) {
                resetActions.classList.remove('hidden');
                resetQuizBtn.disabled = false;
            } else {
                resetActions.classList.add('hidden');
                resetQuizBtn.disabled = true;
            }

            saveState();
        }

        function submitAnswer() {
            if (isEvaluating) {
                return;
            }

            const userAnswer = userAnswerEl.value;
            const correctDefinition = shuffledQuizData[currentQuestionIndex].definition;

            if (userAnswer.trim() === '') {
                feedbackEl.textContent = 'אנא הזן/י תשובה.';
                feedbackContainer.classList.remove('hidden');
                feedbackEl.classList.remove('hidden');
                loader.classList.add('hidden');
                return;
            }

            const state = questionStates[currentQuestionIndex];
            state.answer = userAnswer;
            state.feedback = '';
            state.showAnswer = false;
            state.status = 'in-progress';

            isEvaluating = true;
            updateQuestionIndex();
            saveState();

            feedbackContainer.classList.remove('hidden');
            feedbackEl.textContent = 'מעבד את תשובתך...';
            loader.classList.remove('hidden');
            submitBtn.disabled = true;
            userAnswerEl.disabled = true;
            resetQuizBtn.disabled = true;
            retryBtn.disabled = true;
            correctAnswerContainer.classList.add('hidden');
            correctAnswerEl.classList.add('hidden');
            showAnswerBtn.textContent = 'הצג תשובה מלאה';

            checkWithGemini(userAnswer, correctDefinition);
        }

        function showAnswer() {
            const state = questionStates[currentQuestionIndex];
            const isHidden = correctAnswerEl.classList.toggle('hidden');
            state.showAnswer = !isHidden;
            showAnswerBtn.textContent = isHidden ? 'הצג תשובה מלאה' : 'הסתר תשובה מלאה';

            if (!isHidden) {
                const question = shuffledQuizData[currentQuestionIndex];
                definitionEl.textContent = question.definition;
                explanationEl.textContent = question.explanation;
                tipEl.textContent = question.tip;
            }

            saveState();
        }

        function retryQuestion() {
            if (isEvaluating) {
                return;
            }

            const state = questionStates[currentQuestionIndex];
            state.answer = '';
            state.feedback = '';
            state.showAnswer = false;
            state.status = 'unanswered';

            userAnswerEl.value = '';
            userAnswerEl.disabled = false;
            submitBtn.classList.remove('hidden');
            submitBtn.disabled = false;
            nextBtn.classList.add('hidden');
            feedbackContainer.classList.add('hidden');
            feedbackEl.textContent = '';
            loader.classList.add('hidden');
            correctAnswerContainer.classList.add('hidden');
            correctAnswerEl.classList.add('hidden');
            showAnswerBtn.textContent = 'הצג תשובה מלאה';
            retryBtn.classList.add('hidden');
            retryBtn.disabled = true;

            if (questionStates.some(s => s.status === 'done')) {
                resetActions.classList.remove('hidden');
                resetQuizBtn.disabled = false;
            } else {
                resetActions.classList.add('hidden');
                resetQuizBtn.disabled = true;
            }

            updateQuestionIndex();
            saveState();
            userAnswerEl.focus();
        }

        function nextQuestion() {
            if (isEvaluating) {
                return;
            }
            currentQuestionIndex++;
            loadQuestion();
        }

        function shuffleQuestions() {
            restartQuiz();
        }

        function restartQuiz() {
            if (isEvaluating) {
                return;
            }
            clearSavedState();
            shuffledOrder = [];
            startQuiz(true);
        }

        // --- לוגיקת Gemini API ---

        const apiKey = "AIzaSyAnK5NXA_R_dMSKLYkQL_ka5mywJg5Hkk4";
        const geminiModel = 'gemini-2.5-flash-lite-preview-09-2025';
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${apiKey}`;
        // פונקציה לטיפול ב-Backoff
        async function handleRetry(url, options, n = 5, delay = 1200) {
            try {
                return await fetch(url, options);
            } catch (err) {
                if (n === 1) throw err;
                await new Promise(resolve => setTimeout(resolve, delay));
                return await handleRetry(url, options, n - 1, delay * 2);
            }
        }

        async function sendGeminiRequest({ systemPrompt, userPrompt }) {
            const payload = {
                contents: [{ role: 'user', parts: [{ text: userPrompt }] }],
                systemInstruction: {
                    role: 'system',
                    parts: [{ text: systemPrompt }]
                },
                generationConfig: {
                    maxOutputTokens: 1024,
                    temperature: 0.35,
                    topP: 0.9,
                    topK: 32
                }
            };

            // Explicitly ensure no safety settings are sent to avoid INVALID_ARGUMENT errors.
            delete payload.safetySettings;

            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            const response = await handleRetry(apiUrl, options);

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`HTTP error! status: ${response.status}, message: ${errorData.error?.message || response.statusText}`);
            }

            const result = await response.json();
            console.log('Gemini API Response:', result);

            const candidate = result.candidates?.[0];
            const parts = candidate?.content?.parts || [];
            const text = parts
                .map(part => part?.text || '')
                .join('\n')
                .trim();

            const finishReason = candidate?.finishReason;
            const promptBlock = result.promptFeedback?.blockReason;
            const blockReason = finishReason && finishReason !== 'STOP' ? finishReason : promptBlock || null;

            return { text, blockReason };
        }

        async function checkWithGemini(userAnswer, correctDefinition) {
            const state = questionStates[currentQuestionIndex];
            const systemPrompt = "אתה מורה למטאורולוגיה. השווה בקצרה בין התשובה שלי לבין ההגדרה התקנית. כתוב רק בעברית, עד משפט אחד , ציין מה אפשר לדייק או להוסיף לפי ההגדרה המלאה, תדע לומר את הדבר שישפר ולא סתם מילה חסרה. אם תשובה לא טובה תגיד את זה אבל תחמיא אם צריך, תהיה נעים בתשובה שלך, המטרה שלך היא ללמד. אם התשובה מאוד טובה או מאוד גרועה יכול להכניס בדיחה. אל תתייחס למדיניות או לתהליך הפנימי שלך.";
            const basePrompt = `
                מונח: "${shuffledQuizData[currentQuestionIndex].term}"
                הגדרה נכונה: "${correctDefinition}"
                ---
                תשובה שלי: "${userAnswer}"
                ---
                משוב (בעברית עד שני משפטים):
            `;

            let feedbackText = '';
            let lastBlockReason = null;
            let lastError = null;

            try {
                const { text, blockReason } = await sendGeminiRequest({
                    systemPrompt,
                    userPrompt: basePrompt
                });

                if (text) {
                    feedbackText = text;
                } else if (blockReason) {
                    lastBlockReason = blockReason;
                } else {
                    lastError = new Error('No text returned from Gemini response.');
                }
            } catch (error) {
                console.error('Error calling Gemini API:', error);
                lastError = error;
            }

            loader.classList.add('hidden');

            if (feedbackText) {
                state.feedback = feedbackText.trim();
            } else if (lastBlockReason) {
                state.feedback = `המודל חסם את המשוב (${lastBlockReason}). אפשר ללמוד מההגדרה לדוגמה המצורפת.`;
            } else {
                state.feedback = "לא הצלחתי לקבל משוב מג'מיני כרגע. עיין/י בהגדרה לדוגמה כדי לבדוק את עצמך.";
            }

            if (!feedbackText) {
                state.feedback += `\n\nהגדרה לדוגמה: ${correctDefinition}`;
            }

            state.status = 'done';
            isEvaluating = false;
            feedbackContainer.classList.remove('hidden');
            submitBtn.disabled = false;
            userAnswerEl.disabled = true;
            updateQuestionIndex();
            loadQuestion();
        }

    </script>
</body>

</html>









