<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>בוחן מונחים במטאורולוגיה</title>
    <!-- טעינת Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- טעינת גופן Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Rubik:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* הגדרת גופן ברירת מחדל */
        body {
            font-family: 'Rubik', 'Inter', sans-serif;
        }

        .question-index-wrapper {
            background-color: #f1f5f9;
            border: 1px solid #cbd5f5;
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .question-index-wrapper h2 {
            font-size: 0.95rem;
            font-weight: 600;
            color: #0f172a;
            margin-bottom: 0.75rem;
        }

        .question-index-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            max-height: 10rem;
            overflow-y: auto;
            padding: 0.25rem;
        }

        .question-index-btn {
            width: 2.75rem;
            height: 2.75rem;
            border-radius: 9999px;
            border: 1px solid #cbd5f5;
            background-color: #f8fafc;
            color: #0f172a;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .question-index-btn:hover {
            background-color: #e2e8f0;
        }

        .question-index-btn.is-active {
            background-color: #1d4ed8;
            border-color: #1e3a8a;
            color: #ffffff;
            box-shadow: 0 10px 18px -10px rgba(29, 78, 216, 0.6);
        }

        .question-index-btn.is-in-progress {
            background-color: #fef3c7;
            border-color: #f59e0b;
            color: #92400e;
        }

        .question-index-btn.is-answered {
            background-color: #bae6fd;
            border-color: #0284c7;
            color: #0c4a6e;
        }

        #standalone-nav {
            margin-bottom: 1rem;
        }

        #standalone-nav a {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #0f172a;
            color: #ffffff;
            padding: 0.65rem 1rem;
            border-radius: 0.75rem;
            font-weight: 600;
            text-decoration: none;
            transition: background-color 0.2s ease;
        }

        #standalone-nav a:hover {
            background-color: #1e293b;
        }

        /* סגנון לספינר טעינה */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div class="bg-white rounded-lg shadow-2xl p-6 md:p-8 w-full max-w-2xl mx-auto">
        
        <!-- כותרת ומונה שאלות -->
        <div class="flex justify-between items-center mb-6 pb-4 border-b">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-800">בוחן מונחים במטאורולוגיה</h1>
            <div id="question-counter" class="text-lg font-semibold text-gray-600 bg-gray-100 px-3 py-1 rounded-full"></div>
        </div>

        <div id="standalone-nav" class="hidden">
            <a href="index.html" aria-label="חזרה לתפריט הראשי">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5 8.25 12l7.5-7.5" />
                </svg>
                חזרה לתפריט הראשי
            </a>
        </div>

        <div class="question-index-wrapper" aria-label="ניווט מהיר בין השאלות">
            <h2>ניווט מהיר בין השאלות</h2>
            <div id="question-index" class="question-index-container" role="navigation"></div>
        </div>

        <!-- אזור השאלה -->
        <div id="quiz-container">
            <h2 class="text-xl font-semibold text-blue-700 mb-4">הגדר/י את המונח:</h2>
            <p id="term" class="text-3xl font-bold text-gray-900 mb-5"></p>

            <!-- שדה תשובה -->
            <textarea id="user-answer"
                      class="w-full h-32 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition"
                      placeholder="הקלד/י את הגדרתך כאן..."></textarea>

            <!-- כפתור הגשה -->
            <button id="submit-btn"
                    onclick="submitAnswer()"
                    class="w-full mt-4 bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 transition-colors duration-300 shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                בדוק את תשובתי
            </button>

            <!-- אזור משוב וטעינה -->
            <div id="feedback-container" class="mt-4 min-h-[50px] p-3 bg-gray-50 rounded-lg hidden flex items-center justify-center">
                <div id="loader" class="loader hidden"></div>
                <p id="feedback" class="text-md font-medium text-gray-700 whitespace-pre-line"></p>
            </div>

            <div id="reset-actions" class="mt-4 flex flex-col md:flex-row md:items-center gap-2 hidden">
                <button id="retry-btn"
                        type="button"
                        onclick="retryQuestion()"
                        class="w-full md:w-auto bg-white border border-blue-500 text-blue-600 font-semibold py-2 px-4 rounded-lg hover:bg-blue-50 transition-colors duration-200">
                    נסה/י שוב את השאלה הזו
                </button>
                <button id="reset-quiz-btn"
                        type="button"
                        onclick="restartQuiz()"
                        class="w-full md:w-auto bg-blue-100 text-blue-800 font-semibold py-2 px-4 rounded-lg hover:bg-blue-200 transition-colors duration-200">
                    אפס/י את כל המבחן
                </button>
            </div>

            <!-- אזור תשובה נכונה (מוסתר) -->
            <div id="correct-answer-container" class="mt-6 hidden border-t pt-4">
                <button id="show-answer-btn"
                        onclick="showAnswer()"
                        class="text-sm text-blue-600 hover:underline mb-3 font-medium">
                    הצג/הסתר תשובה מלאה
                </button>
                
                <div id="correct-answer" class="hidden bg-green-50 border border-green-200 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-green-800">הגדרה מדויקת:</h3>
                    <p id="definition" class="text-md text-green-900 mb-3"></p>
                    
                    <h3 class="text-lg font-bold text-green-800">הסבר:</h3>
                    <p id="explanation" class="text-md text-green-900 mb-3"></p>
                    
                    <h3 class="text-lg font-bold text-green-800">טיפ לזכירה:</h3>
                    <p id="tip" class="text-md text-green-900 italic"></p>
                </div>
            </div>

            <!-- כפתור שאלה הבאה (מוסתר) -->
            <button id="next-btn"
                    onclick="nextQuestion()"
                    class="w-full mt-4 bg-gray-700 text-white font-bold py-3 px-4 rounded-lg hover:bg-gray-800 transition-colors duration-300 shadow-md hidden focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                השאלה הבאה
            </button>
        </div>

        <!-- מסך סיום -->
        <div id="completion-screen" class="text-center hidden">
            <h2 class="text-3xl font-bold text-gray-800 mb-4">כל הכבוד!</h2>
            <p class="text-xl text-gray-600 mb-6">סיימת את הבוחן בהצלחה.</p>
            <button onclick="restartQuiz()"
                    class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 transition-colors duration-300 shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                התחל מחדש
            </button>
        </div>
    </div>

    <script>
        // מאגר השאלות מבוסס על 26 המונחים מקובץ ה-PDF
        const quizData = [
            // --- 12 המונחים המקוריים ---
            {
                term: "טמפרטורת נקודת הטל",
                definition: "הטמפרטורה שיש לקרר אליה את גוש האוויר בתהליך איזוברי (בלחץ קבוע) על מנת שתתרחש רוויה.",
                explanation: "זו הטמפרטורה שבה האוויר כבר לא יכול להחזיק את כל אדי המים שבו, והם מתחילים להתעבות לטיפות מים זעירות (כמו טל, ערפל או עננים). ככל שנקודת הטל קרובה יותר לטמפרטורת האוויר, כך האוויר לח יותר.",
                tip: "חשבו על 'נקודה' שבה האוויר 'מטפטף' - הטמפרטורה שבה ה'טל' מתחיל להיווצר."
            },
            {
                term: "שקע ברומטרי",
                definition: "אזור בו לחץ האוויר נמוך ביחס לסביבתו.",
                explanation: "בגלל הלחץ הנמוך, אוויר מהסביבה זורם פנימה (מתכנס) אל מרכז השקע. האוויר הזה חייב לעלות למעלה, מה שגורם להתקררות, התעבות ועננות. לכן, שקעים מזוהים עם מזג אוויר לא יציב, עננים ומשקעים.",
                tip: "שקע = 'שוקע' פנימה. אוויר נכנס פנימה ועולה למעלה, כמו מים שיורדים בכיור (בצורה הפוכה)."
            },
            {
                term: "כוח קוריוליס",
                definition: "כוח מדומה הפועל על גופים בתוך מערכות מסתובבות, הגורם להטיה בתנועתם.",
                explanation: "בגלל שכדור הארץ מסתובב, כל גוף שנע (כמו אוויר או מים) מוסט מהנתיב הישר שלו. בחצי הכדור הצפוני, ההטיה היא תמיד ימינה לכיוון התנועה. בחצי הכדור הדרומי, ההטיה היא שמאלה. כוח זה הוא שגורם לרוחות להסתובב סביב שקעים ורמות במקום לזרום ישר מהרמה לשקע.",
                tip: "קוריוליס = 'סיבוב'. בגלל סיבוב כדור הארץ, הרוח 'מחליקה' ימינה (בצפון)."
            },
            {
                term: "טרופוספרה",
                definition: "השכבה הנמוכה ביותר של האטמוספירה, שבה מתרחשות כל תופעות מזג האוויר.",
                explanation: "שכבה זו מתחילה מהקרקע ומגיעה לגובה של כ-10-12 ק\"מ. היא מאופיינת בכך שהטמפרטורה יורדת ככל שעולים בגובה. היא מכילה כ-75% ממסת האוויר וכמעט את כל אדי המים.",
                tip: "טרופו = 'שינוי' (מיוונית). זו השכבה שבה מזג האוויר כל הזמן משתנה."
            },
            {
                term: "זרם סילון",
                definition: "רצועה צרה של רוחות חזקות מאוד (מעל 75 קשר) בגבהי הטיסה (ברום הטרופוספרה).",
                explanation: "זרמי הסילון נוצרים בגבולות בין גושי אוויר עם טמפרטורות שונות. הם זורמים ממערב למזרח ומשפיעים מאוד על מסלולי הטיסה ועל התפתחות מערכות מזג אוויר על הקרקע.",
                tip: "סילון = מטוס סילון. זוהי 'אוטוסטרדה' של רוח מהירה בגובה שבו טסים מטוסי סילון."
            },
            {
                term: "מפל אדיאבטי יבש",
                definition: "קצב ההתקררות של גוש אוויר לא רווי (יבש) בעת עלייתו, כ-9.8 מעלות צלזיוס לכל 1000 מטר.",
                explanation: "כשאוויר עולה, הלחץ סביבו יורד, והוא מתפשט. פעולת ההתפשטות גורמת להתקררות. כל עוד הוא לא רווי, הוא מתקרר בקצב קבוע זה.",
                tip: "יבש = מהיר. אוויר יבש מתקרר מהר בעלייה (כמעט 10° לק\"מ)."
            },
            {
                term: "רמה ברומטרית",
                definition: "אזור בו לחץ האוויר גבוה ביחס לסביבתו.",
                explanation: "בגלל הלחץ הגבוה, אוויר ממרכז הרמה זורם החוצה (מתבדר). אוויר מהשכבות הגבוהות שוקע (מתמוכך) למטה. אוויר שוקע מתחמם ומתייבש, ולכן רמות מזוהות עם מזג אוויר יציב ושמיים בהירים.",
                tip: "רמה = 'רם' וגבוה. אוויר יורד מלמעלה ומתפזר, מדכא עננים וגורם למזג אוויר נאה."
            },
            {
                term: "שקע חזיתי",
                definition: "שקע ברומטרי שנוצר כתוצאה ממפגש בין גוש אוויר קר לגוש אוויר חם.",
                explanation: "זהו השקע ה'קלאסי' של קווי הרוחב הבינוניים (כמו שקע קפריסאי בחורף). המפגש בין גושי האוויר יוצר חזיתות (חמה וקרה), עלייה של אוויר, עננים ומשקעים.",
                tip: "חזיתי = חזית/מלחמה. זוהי 'מלחמה' בין אוויר חם לאוויר קר, שיוצרת שקע ומזג אוויר סוער."
            },
            {
                term: "מפל אדיאבטי לח",
                definition: "קצב ההתקררות של גוש אוויר רווי בעת עלייתו, כ-6 מעלות צלזיוס לכל 1000 מטר (בממוצע).",
                explanation: "כאשר גוש אוויר רווי עולה ומתקרר, אדי המים שבו מתעבים לעננים. תהליך ההתעבות משחרר חום כמוס, אשר 'מחמם' את גוש האוויר ומאט את קצב ההתקררות שלו.",
                tip: "לח = לאט. אוויר לח (רווי) מתקרר לאט יותר, כי יצירת הענן משחררת חום שמפצה על ההתקררות."
            },
            {
                term: "התקרחות זגוגית",
                definition: "הצטברות קרח חלקה, שקופה וקשה, הנגרמת מטיפות מים גדולות בקירור-יתר שקופאות על כנף המטוס תוך כדי החלקה לאחור.",
                explanation: "זוהי הצורה המסוכנת ביותר של התקרחות. היא מתרחשת כשהמטוס טס דרך טיפות מים גדולות (כמו גשם קל) שנמצאות בטמפרטורה מתחת לאפס. היא משנה בצורה חמורה את צורת הכנף ופוגעת בעילוי.",
                tip: "זגוגית = כמו זכוכית. קרח חלק ושקוף כמו זכוכית, ש'מזגג' את הכנף."
            },
            {
                term: "חוק בויס בלוט",
                definition: "כלל אצבע הקובע את הקשר בין כיוון הרוח למיקום מערכות הלחץ.",
                explanation: "בחצי הכדור הצפוני, אם עומדים עם הגב לרוח, הלחץ הנמוך (השקע) יהיה בצד שמאל והלחץ הגבוה (הרמה) יהיה בצד ימין. (בחצי הכדור הדרומי - הפוך).",
                tip: "בויס בלוט = שמאל נמוך. כשאתה עם הגב לרוח (בצפון), צד שמאל שלך מצביע על הלחץ הנמוך."
            },
            {
                term: "אינברסיה",
                definition: "מצב שבו הטמפרטורה עולה עם הגובה, בניגוד למצב הרגיל בטרופוספרה.",
                explanation: "במצב רגיל האוויר קר למעלה וחם למטה. באינברסיה, יש שכבת אוויר חם מעל אוויר קר. השכבה החמה פועלת כ'מכסה' ומונעת מהאוויר שמתחתיה לעלות. זהו מצב יציב מאוד ש'כולא' זיהום אוויר, אובך ולחות קרוב לקרקע.",
                tip: "אינברסיה = היפוך (Inverse). הטמפרטורה מתהפכת ועולה עם הגובה במקום לרדת."
            },
            
            // --- 14 המונחים הנוספים ---
            {
                term: "טרופופאוזה",
                definition: "שכבת הביניים הדקה המפרידה בין הטרופוספרה לסטרטוספרה.",
                explanation: "זוהי הנקודה שבה הטמפרטורה מפסיקה לרדת עם הגובה (כמו בטרופוספרה) ומתחילה להישאר קבועה או לעלות (כמו בסטרטוספרה). גובה הטרופופאוזה משמש כ'תקרה' להתפתחות רוב העננים ומערכות מזג האוויר.",
                tip: "פאוזה = הפסקה. זוהי ההפסקה שבין הטרופוספרה לסטרטוספרה, שם מפל הטמפרטורה עושה 'הפסקה'."
            },
            {
                term: "יציבות",
                definition: "היכולת של גוש אוויר להישאר במקומו הנוכחי או לחזור אליו לאחר הפרעה.",
                explanation: "אוויר יציב הוא אוויר שקר מסביבתו, ואם דוחפים אותו למעלה הוא ירצה לרדת בחזרה (כמו כדור בעמק). אוויר בלתי יציב הוא חם מסביבתו, וימשיך לעלות. יציבות מדכאת עננים, אי-יציבות מעודדת עננים ערמתיים וסערות.",
                tip: "יציב = נשאר במקום. אוויר יציב לא אוהב לזוז וגורם למזג אוויר רגוע."
            },
            {
                term: "פרץ רוח",
                definition: "עלייה פתאומית, קצרה וחזקה במהירות הרוח, מעל המהירות הממוצעת.",
                explanation: "פרצי רוח נגרמים לרוב על ידי ערבול באטמוספירה, או על ידי זרמים יורדים חזקים מענני סערה (כמו מיקרוברסט). הם מהווים סכנה תעופתית, במיוחד בהמראה ונחיתה.",
                tip: "פרץ = פתאומי. כמו פרץ מים, זוהי 'מכה' פתאומית וחזקה של רוח."
            },
            {
                term: "סטרטוקומולוס (Sc)",
                definition: "ענן שכבתי (סטרטוס) בעל התפתחות ערמתית (קומולוס) מעטה. נראה כגוש או שכבה של עננים אפורים או לבנבנים.",
                explanation: "אלו עננים נמוכים שנראים לעיתים קרובות כ'שמיכת טלאים' בשמיים. הם נוצרים לרוב מהתפשטות של ענני קומולוס שנתקלים בשכבת אינברסיה. עשויים להוריד גשם קל או רסס.",
                tip: "סטרטו (שכבתי) + קומולוס (ערמתי) = ערימות מרוחות בשכבה."
            },
            {
                term: "קרינה קצרת גל",
                definition: "קרינה אלקטרומגנטית בעלת אורך גל קצר, הנפלטת מגופים חמים מאוד, כמו השמש (כולל אור נראה).",
                explanation: "האטמוספירה שקופה יחסית לקרינה זו, ולכן היא מצליחה להגיע לקרקע ולחמם אותה. הקרקע, שהיא קרה יותר, פולטת בחזרה קרינה ארוכת גל (אינפרה-אדום), שהיא 'נבלעת' על ידי גזי חממה.",
                tip: "קצר = חם. השמש החמה פולטת קרינה קצרה."
            },
            {
                term: "חזית חמה",
                definition: "אזור מפגש שבו גוש אוויר חם נע לעבר גוש אוויר קר ותופס את מקומו.",
                explanation: "מכיוון שהאוויר החם קל יותר, הוא 'מטפס' במתינות מעל האוויר הקר הנסוג. הטיפוס המתון יוצר עננות שכבתית נרחבת (סטרטוס, נימבוסטרטוס) וגשם קל ומתמשך.",
                tip: "חזית חמה = טיפוס מתון. האוויר החם מטפס לאט לאט על הקר, ויוצר 'שטיח' ארוך של עננים וגשם."
            },
            {
                term: "צירוס (Ci)",
                definition: "ענן גבוה (מעל 6 ק\"מ) המורכב מגבישי קרח, הנראה בצורת סיבים, שערות או נוצות לבנות ועדינות.",
                explanation: "אלו העננים הגבוהים ביותר, הם דקים ושקופים יחסית לשמש ולירח. הופעתם יכולה לעתים לבשר על התקרבות של מערכת מזג אוויר.",
                tip: "צירוס נשמע כמו 'סירוס' (מסרק). העננים נראים כמו סיבים עדינים ש'סירקו' בשמיים."
            },
            {
                term: "מיקרוברסט (Microburst)",
                definition: "זרם אוויר יורד (downdraft) חזק ומרוכז מאוד, הפוגע בקרקע ומתפשט החוצה לכל הכיוונים.",
                explanation: "זוהי תופעה מסוכנת ביותר לתעופה, במיוחד בהמראה ונחיתה. היא נוצרת לרוב בענני סערה (Cb) וגורמת לשינויים פתאומיים ברוח (גזירת רוח).",
                tip: "מיקרו = קטן ומרוכז, ברסט = התפרצות. התפרצות אוויר קטנה, מרוכזת ומסוכנת מאוד."
            },
            {
                term: "קומולוס (Cu)",
                definition: "ענן ערימתי מבודד, בעל בסיס אופקי וכהה ופסגות מעוגלות ולבנות (נראה כמו 'צמר גפן' או כרובית).",
                explanation: "אלו עננים של 'מזג אוויר נאה', הנוצרים כתוצאה מעליית אוויר חם (קונבקציה) מהקרקע. במצבי אי-יציבות, הם יכולים להתפתח לענני סערה (קומולונימבוס).",
                tip: "קומולוס = ערימה (מלטינית). ענן שנראה כמו ערימה של צמר גפן."
            },
            {
                term: "טמפרטורה לחה",
                definition: "הטמפרטורה הנמוכה ביותר שאליה ניתן לקרר גוש אוויר על ידי אידוי מים לתוכו עד לרוויה.",
                explanation: "זוהי הטמפרטורה שמודד מדחום שכוסה בבד לח. ככל שהאוויר יבש יותר, כך האידוי חזק יותר, והטמפרטורה הלחה נמוכה יותר מטמפרטורת האוויר.",
                tip: "לחה = מדחום לח. מה שמדחום עם 'גרב' לחה היה מראה."
            },
            {
                term: "סטרטוס (St)",
                definition: "ענן שכבתי נמוך מאוד (בגובה מאות מטרים), אפור ואחיד, שגבולותיו אינם חדים.",
                explanation: "ענן זה נראה כשכבת ערפל 'שהתרוממה' מהקרקע. אם הוא יורד ונוגע בקרקע, הוא נקרא 'ערפל'. הוא מלווה בראות לקויה ויכול להוריד רסס קל.",
                tip: "סטרטוס = שטיח (מלטינית 'שכבה'). ענן שנראה כמו שטיח אפור ואחיד בשמיים."
            },
            {
                term: "לחות יחסית",
                definition: "היחס (באחוזים) בין כמות אדי המים הנמצאת באוויר לבין הכמות המקסימלית שאותה האוויר יכול להכיל באותה טמפרטורה.",
                explanation: "100% לחות יחסית משמעו שהאוויר רווי. לחות יחסית תלויה מאוד בטמפרטורה: אוויר חם יכול להכיל יותר אדי מים מאשר אוויר קר.",
                tip: "יחסית = יחס לטמפרטורה. כמה האוויר 'מלא' באדים, יחסית למקסימום שהוא יכול להחזיק בטמפרטורה הנוכחית."
            },
            {
                term: "מערכת לחץ",
                definition: "תבנית מאורגנת של לחץ אטמוספרי, המתבטאת באזור של לחץ גבוה (רמה) או לחץ נמוך (שקע) ביחס לסביבה.",
                explanation: "מערכות לחץ קובעות את כיוון הרוח ואת אופי מזג האוויר. שקעים (לחץ נמוך) גורמים לעליית אוויר ומשקעים. רמות (לחץ גבוה) גורמות לשקיעת אוויר ומזג אוויר נאה.",
                tip: "מערכת = רמה או שקע. אלו המנועים הגדולים של מזג האוויר."
            },
            {
                term: "שקע תרמלי",
                definition: "שקע (לחץ נמוך) הנוצר כתוצאה מהתחממות חזקה של הקרקע באזור מסוים, הגורמת לאוויר שמעל לעלות.",
                explanation: "כאשר הקרקע מתחממת מאוד (למשל, מדבר בקיץ), האוויר שמעליה עולה. עליית האוויר יוצרת 'חוסר' אוויר בקרקע, כלומר לחץ נמוך. דוגמה לכך היא האפיק הפרסי.",
                tip: "תרמלי = חום. שקע שנוצר בגלל חום מהקרקע."
            }
        ];


        let currentQuestionIndex = 0;
        let shuffledQuizData = [];
        let isEvaluating = false;

        // רכיבי DOM
        const quizContainer = document.getElementById('quiz-container');
        const completionScreen = document.getElementById('completion-screen');
        const questionCounter = document.getElementById('question-counter');
        const termEl = document.getElementById('term');
        const userAnswerEl = document.getElementById('user-answer');
        const submitBtn = document.getElementById('submit-btn');
        const nextBtn = document.getElementById('next-btn');
        const feedbackContainer = document.getElementById('feedback-container');
        const loader = document.getElementById('loader');
        const feedbackEl = document.getElementById('feedback');
        const showAnswerBtn = document.getElementById('show-answer-btn');
        const correctAnswerContainer = document.getElementById('correct-answer-container');
        const correctAnswerEl = document.getElementById('correct-answer');
        const definitionEl = document.getElementById('definition');
        const explanationEl = document.getElementById('explanation');
        const tipEl = document.getElementById('tip');
        const questionIndexContainer = document.getElementById('question-index');
        const standaloneNav = document.getElementById('standalone-nav');
        const resetActions = document.getElementById('reset-actions');
        const retryBtn = document.getElementById('retry-btn');
        const resetQuizBtn = document.getElementById('reset-quiz-btn');

        const STORAGE_KEY = 'definitions_quiz_state_v1';
        let shuffledOrder = [];
        let questionStates = [];

        document.addEventListener('DOMContentLoaded', () => {
            if (window.self === window.top) {
                standaloneNav.classList.remove('hidden');
            }
            startQuiz();
        });

        function createEmptyState() {
            return { answer: '', feedback: '', showAnswer: false, status: 'unanswered' };
        }

        function loadSavedState() {
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (!stored) {
                    return null;
                }

                const parsed = JSON.parse(stored);
                if (!Array.isArray(parsed.order) || parsed.order.length !== quizData.length) {
                    localStorage.removeItem(STORAGE_KEY);
                    return null;
                }

                if (!Array.isArray(parsed.questionStates) || parsed.questionStates.length !== quizData.length) {
                    localStorage.removeItem(STORAGE_KEY);
                    return null;
                }

                if (!parsed.order.every(idx => Number.isInteger(idx) && idx >= 0 && idx < quizData.length)) {
                    localStorage.removeItem(STORAGE_KEY);
                    return null;
                }

                const sanitizedStates = parsed.questionStates.map(state => ({
                    answer: typeof state?.answer === 'string' ? state.answer : '',
                    feedback: typeof state?.feedback === 'string' ? state.feedback : '',
                    showAnswer: Boolean(state?.showAnswer),
                    status: state?.status === 'done' ? 'done' : 'unanswered'
                }));

                const savedIndex = Number.isInteger(parsed.currentQuestionIndex) ? parsed.currentQuestionIndex : 0;

                return {
                    order: parsed.order.slice(),
                    questionStates: sanitizedStates,
                    currentQuestionIndex: Math.min(Math.max(savedIndex, 0), quizData.length - 1),
                    completed: Boolean(parsed.completed)
                };
            } catch (error) {
                console.warn('Failed to load saved quiz state', error);
                return null;
            }
        }

        function saveState(extra = {}) {
            try {
                const payload = {
                    order: shuffledOrder,
                    questionStates,
                    currentQuestionIndex,
                    completed: extra.completed !== undefined ? extra.completed : !completionScreen.classList.contains('hidden')
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
            } catch (error) {
                console.warn('Failed to save quiz state', error);
            }
        }

        function clearSavedState() {
            try {
                localStorage.removeItem(STORAGE_KEY);
            } catch (error) {
                console.warn('Failed to clear quiz state', error);
            }
        }

        function renderQuestionIndex() {
            questionIndexContainer.innerHTML = '';
            shuffledQuizData.forEach((_, index) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.textContent = index + 1;
                button.className = 'question-index-btn';
                button.addEventListener('click', () => goToQuestion(index));
                questionIndexContainer.appendChild(button);
            });
        }

        function updateQuestionIndex() {
            const buttons = questionIndexContainer.querySelectorAll('button');
            buttons.forEach((btn, idx) => {
                btn.classList.remove('is-active', 'is-in-progress', 'is-answered');
                if (idx === currentQuestionIndex) {
                    btn.classList.add('is-active');
                }
                const state = questionStates[idx];
                if (!state) {
                    return;
                }
                if (state.status === 'done') {
                    btn.classList.add('is-answered');
                } else if (state.status === 'in-progress') {
                    btn.classList.add('is-in-progress');
                }
            });
        }

        function goToQuestion(index) {
            if (isEvaluating) {
                return;
            }
            currentQuestionIndex = index;
            loadQuestion();
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function startQuiz(reset = false) {
            let savedState = null;
            if (!reset) {
                savedState = loadSavedState();
            }

            if (savedState) {
                shuffledOrder = savedState.order.slice();
                shuffledQuizData = shuffledOrder.map(idx => quizData[idx]);
                questionStates = savedState.questionStates;
                currentQuestionIndex = savedState.currentQuestionIndex;
                isEvaluating = false;
                quizContainer.classList.toggle('hidden', savedState.completed);
                completionScreen.classList.toggle('hidden', !savedState.completed);
                renderQuestionIndex();
                if (savedState.completed) {
                    updateQuestionIndex();
                    saveState({ completed: true });
                } else {
                    loadQuestion();
                }
                return;
            }

            shuffledOrder = shuffleArray(Array.from({ length: quizData.length }, (_, idx) => idx));
            shuffledQuizData = shuffledOrder.map(idx => quizData[idx]);
            questionStates = shuffledQuizData.map(() => createEmptyState());
            currentQuestionIndex = 0;
            isEvaluating = false;
            quizContainer.classList.remove('hidden');
            completionScreen.classList.add('hidden');
            renderQuestionIndex();
            loadQuestion();
            saveState();
        }

        function loadQuestion() {
            updateQuestionIndex();

            if (currentQuestionIndex >= shuffledQuizData.length) {
                quizContainer.classList.add('hidden');
                completionScreen.classList.remove('hidden');
                saveState({ completed: true });
                return;
            }

            const question = shuffledQuizData[currentQuestionIndex];
            const state = questionStates[currentQuestionIndex];

            termEl.textContent = question.term;
            questionCounter.textContent = `שאלה ${currentQuestionIndex + 1} / ${shuffledQuizData.length}`;

            userAnswerEl.value = state.answer || '';
            loader.classList.add('hidden');

            if (state.status === 'done') {
                userAnswerEl.disabled = true;
                feedbackContainer.classList.remove('hidden');
                feedbackEl.textContent = state.feedback || '';
                submitBtn.classList.add('hidden');
                submitBtn.disabled = false;
                nextBtn.classList.remove('hidden');
                nextBtn.textContent = currentQuestionIndex === shuffledQuizData.length - 1 ? 'סיום הבוחן' : 'השאלה הבאה';
                correctAnswerContainer.classList.remove('hidden');
                retryBtn.classList.remove('hidden');
                retryBtn.disabled = false;
                if (state.showAnswer) {
                    correctAnswerEl.classList.remove('hidden');
                    showAnswerBtn.textContent = 'הסתר תשובה מלאה';
                    definitionEl.textContent = question.definition;
                    explanationEl.textContent = question.explanation;
                    tipEl.textContent = question.tip;
                } else {
                    correctAnswerEl.classList.add('hidden');
                    showAnswerBtn.textContent = 'הצג תשובה מלאה';
                }
            } else {
                userAnswerEl.disabled = false;
                feedbackContainer.classList.add('hidden');
                feedbackEl.textContent = '';
                submitBtn.classList.remove('hidden');
                submitBtn.disabled = false;
                nextBtn.classList.add('hidden');
                correctAnswerContainer.classList.add('hidden');
                correctAnswerEl.classList.add('hidden');
                showAnswerBtn.textContent = 'הצג תשובה מלאה';
                retryBtn.classList.add('hidden');
                retryBtn.disabled = true;
                if (state.status === 'in-progress') {
                    feedbackContainer.classList.remove('hidden');
                    feedbackEl.textContent = 'מעבד את תשובתך...';
                }
            }

            if (questionStates.some(s => s.status === 'done')) {
                resetActions.classList.remove('hidden');
                resetQuizBtn.disabled = false;
            } else {
                resetActions.classList.add('hidden');
                resetQuizBtn.disabled = true;
            }

            saveState();
        }

        function submitAnswer() {
            if (isEvaluating) {
                return;
            }

            const userAnswer = userAnswerEl.value;
            const correctDefinition = shuffledQuizData[currentQuestionIndex].definition;

            if (userAnswer.trim() === '') {
                feedbackEl.textContent = 'אנא הזן/י תשובה.';
                feedbackContainer.classList.remove('hidden');
                feedbackEl.classList.remove('hidden');
                loader.classList.add('hidden');
                return;
            }

            const state = questionStates[currentQuestionIndex];
            state.answer = userAnswer;
            state.feedback = '';
            state.showAnswer = false;
            state.status = 'in-progress';

            isEvaluating = true;
            updateQuestionIndex();
            saveState();

            feedbackContainer.classList.remove('hidden');
            feedbackEl.textContent = 'מעבד את תשובתך...';
            loader.classList.remove('hidden');
            submitBtn.disabled = true;
            userAnswerEl.disabled = true;
            resetQuizBtn.disabled = true;
            retryBtn.disabled = true;
            correctAnswerContainer.classList.add('hidden');
            correctAnswerEl.classList.add('hidden');
            showAnswerBtn.textContent = 'הצג תשובה מלאה';

            checkWithGemini(userAnswer, correctDefinition);
        }

        function showAnswer() {
            const state = questionStates[currentQuestionIndex];
            const isHidden = correctAnswerEl.classList.toggle('hidden');
            state.showAnswer = !isHidden;
            showAnswerBtn.textContent = isHidden ? 'הצג תשובה מלאה' : 'הסתר תשובה מלאה';

            if (!isHidden) {
                const question = shuffledQuizData[currentQuestionIndex];
                definitionEl.textContent = question.definition;
                explanationEl.textContent = question.explanation;
                tipEl.textContent = question.tip;
            }

            saveState();
        }

        function retryQuestion() {
            if (isEvaluating) {
                return;
            }

            const state = questionStates[currentQuestionIndex];
            state.answer = '';
            state.feedback = '';
            state.showAnswer = false;
            state.status = 'unanswered';

            userAnswerEl.value = '';
            userAnswerEl.disabled = false;
            submitBtn.classList.remove('hidden');
            submitBtn.disabled = false;
            nextBtn.classList.add('hidden');
            feedbackContainer.classList.add('hidden');
            feedbackEl.textContent = '';
            loader.classList.add('hidden');
            correctAnswerContainer.classList.add('hidden');
            correctAnswerEl.classList.add('hidden');
            showAnswerBtn.textContent = 'הצג תשובה מלאה';
            retryBtn.classList.add('hidden');
            retryBtn.disabled = true;

            if (questionStates.some(s => s.status === 'done')) {
                resetActions.classList.remove('hidden');
                resetQuizBtn.disabled = false;
            } else {
                resetActions.classList.add('hidden');
                resetQuizBtn.disabled = true;
            }

            updateQuestionIndex();
            saveState();
            userAnswerEl.focus();
        }

        function nextQuestion() {
            if (isEvaluating) {
                return;
            }
            currentQuestionIndex++;
            loadQuestion();
        }

        function restartQuiz() {
            if (isEvaluating) {
                return;
            }
            clearSavedState();
            shuffledOrder = [];
            startQuiz(true);
        }

        // --- לוגיקת Gemini API ---

        const apiKey = "AIzaSyC_DLS4a-6tU26oME_NqYQfIFfSg8rg1fo";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        // פונקציה לטיפול ב-Backoff
        async function handleRetry(url, options, n = 5, delay = 1200) {
            try {
                return await fetch(url, options);
            } catch (err) {
                if (n === 1) throw err;
                await new Promise(resolve => setTimeout(resolve, delay));
                return await handleRetry(url, options, n - 1, delay * 2);
            }
        }

        function sanitizeAnswer(text) {
            if (!text) {
                return '';
            }

            return text
                .replace(/[\u0000-\u001F\u007F]/g, ' ')
                .replace(/[<>]/g, ' ')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        async function requestGeminiFeedback({ systemPrompt, userPrompt }) {
            const payload = {
                contents: [{ role: 'user', parts: [{ text: userPrompt }] }],
                systemInstruction: {
                    role: 'system',
                    parts: [{ text: systemPrompt }]
                },
                generationConfig: {
                    maxOutputTokens: 1024,
                    temperature: 0.35,
                    topP: 0.9,
                    topK: 32
                },
                safetySettings: [
                    { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' },
                    { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
                    { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
                    { category: 'HARM_CATEGORY_SEXUAL_CONTENT', threshold: 'BLOCK_NONE' }
                ]
            };

            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            const response = await handleRetry(apiUrl, options);

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`HTTP error! status: ${response.status}, message: ${errorData.error?.message || response.statusText}`);
            }

            const result = await response.json();
            console.log('Gemini API Response:', result);

            const candidate = result.candidates?.[0];
            const parts = candidate?.content?.parts || [];
            const text = parts
                .map(part => part?.text || '')
                .join('\n')
                .trim();

            const finishReason = candidate?.finishReason;
            const promptBlock = result.promptFeedback?.blockReason;
            const blockReason = finishReason && finishReason !== 'STOP' ? finishReason : promptBlock || null;

            return { text, blockReason };
        }

        async function checkWithGemini(userAnswer, correctDefinition) {
            const state = questionStates[currentQuestionIndex];
            const systemPrompt = "אתה מורה למטאורולוגיה. השווה בקצרה בין תשובת הסטודנט לבין ההגדרה התקנית. כתוב רק בעברית, עד שלושה משפטים, ציין מה חסר ואם התשובה טובה תן חיזוק. אל תתייחס למדיניות או לתהליך הפנימי שלך.";
            const basePrompt = `
                מונח: "${shuffledQuizData[currentQuestionIndex].term}"
                הגדרה נכונה: "${correctDefinition}"
                ---
                תשובת סטודנט: "${userAnswer}"
                ---
                משוב (בעברית עד שלושה משפטים):
            `;

            const sanitizedAnswer = sanitizeAnswer(userAnswer);
            const attempts = [
                { label: 'original', prompt: basePrompt },
                ...(sanitizedAnswer && sanitizedAnswer !== userAnswer.trim()
                    ? [{ label: 'sanitized', prompt: `
                מונח: "${shuffledQuizData[currentQuestionIndex].term}"
                הגדרה נכונה: "${correctDefinition}"
                ---
                תשובת סטודנט (מעובדת לבטיחות): "${sanitizedAnswer}"
                ---
                משוב (בעברית עד שלושה משפטים):
            ` }]
                    : [])
            ];

            let feedbackText = '';
            let lastBlockReason = null;
            let lastError = null;

            for (const attempt of attempts) {
                try {
                    const { text, blockReason } = await requestGeminiFeedback({
                        systemPrompt,
                        userPrompt: attempt.prompt
                    });

                    if (text) {
                        feedbackText = text;
                        break;
                    }

                    if (blockReason) {
                        lastBlockReason = blockReason;
                        console.warn('Gemini block reason:', blockReason, 'during', attempt.label, 'attempt');
                        continue;
                    }

                    lastError = new Error('No text returned from Gemini response.');
                } catch (error) {
                    console.error('Error calling Gemini API:', error);
                    lastError = error;
                }
            }

            loader.classList.add('hidden');

            if (feedbackText) {
                state.feedback = feedbackText.trim();
            } else if (lastBlockReason) {
                state.feedback = `המודל חסם את המשוב (${lastBlockReason}). אפשר ללמוד מההגדרה לדוגמה המצורפת.`;
            } else {
                state.feedback = "לא הצלחתי לקבל משוב מג'מיני כרגע. עיין/י בהגדרה לדוגמה כדי לבדוק את עצמך.";
            }

            if (!feedbackText) {
                state.feedback += `\n\nהגדרה לדוגמה: ${correctDefinition}`;
            }

            state.status = 'done';
            isEvaluating = false;
            feedbackContainer.classList.remove('hidden');
            submitBtn.disabled = false;
            userAnswerEl.disabled = true;
            updateQuestionIndex();
            loadQuestion();
        }

    </script>
</body>

</html>


